package com.izayacity.algorithms.tree;

/**
 * Created by Francis Yang on 5/4/17.
 */
public class Problem {
/**
 * Problem 4.1 Route Between Nodes: Given a directed graph, design an algorithm to find out whether there is a route
 * between two nodes.
 */

/**
 *  Problem 4.2 Minimal tree: Given a sorted (increasing order) array with unique integer elements, write an algorithm
 *  to create a binary search tree with minimal height.
 */

/**
 * Problem 4.3 List of Depths: Given a binary tree, design an algorithm which creates a linked list of all the nodes at
 * each depth (e.g., if you have a tree with depth D, you'll have D linked lists).
 */

/**
 * Problem 4.4 Check Balanced: Implement a function to check if a binary tree is balanced. For the purposes of this
 * question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ
 * by more than one.
 */

/**
 * Problem 4.5 Validate BST: Implemented a function to check if a binary tree is a binary search tree.
 */

/**
 * Problem 4.6 Successor: Write an algorithm to find the "next" node (i.e., in-order successor) of a given node in a
 * binary search tree. You may assume that each node has a link to its parent.
 */

/**
 * Problem 4.7 Build Order: You are given a list of projects and a list of dependencies (which is a list of pairs of
 * projects, where the first project is dependent on the second project). All of a project's dependencies must be
 * built before the projects is. Find a build order that will allow the projects to be built. If there is no valid
 * order, return an error.
 * E.g. Input:
 * projects: a, b, c, d, e, f
 * dependencies: (d, a), (b, f), (d, b), (a, f), (c, d)
 * Output: f, e, a, b, d, c
 */

/**
 * Problem 4.8 First Common Ancestor: Design an algorithm and write code to find the first common ancestor of two nodes
 * in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree.
 */

/**
 * Problem 4.9 BST Sequences: A binary search tree was created by traversing through an array from left to right and
 * inserting each element. Given a binary search tree with distinct elements, print all possible arrays that could
 * have led to this tree.
 * E.g. Input: 2->1, 2->3
 * Output: {2, 1, 3}, {2, 3, 1}
 */

/**
 * Problem 4.10 Check Subtree: T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an
 * algorithm to determine if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node n in T1 such
 * that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the 2 trees would be identical.
 */

/**
 * Problem 4.11 Random Node: You are implementing a binary tree class from scratch which, in addition to insert, find,
 * and delete, has a method getRandomNode () which returns a random node from the tree. All nodes should be equally
 * likely to be chosen. Design and implement an algorithm for getRandomNode, and explain how you would implement the
 * rest of the methods.
 */

/**
 * Problem 4.12 Paths with Sum: You are given a binary tree in which each node contains an integer value (which might be
 * positive or negative). Design an algorithm to count the number of paths that sum to a given value. The path does not
 * need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
 */
}
